// Generated by CoffeeScript 2.6.1
(function() {
  /*
   * mustache-file.js - wrapper around mustache
   *
   * For fully documented souce code, please see the coffeescript
   * source on Github.
   *
   * Version: 0.1.6
   *
   */
  var Async, Mustache, Path, Pretty, fs, mustache, partialRE;

  fs = require('fs');

  mustache = require('mustache');

  Path = require('path');

  Async = require('async');

  Pretty = require('pretty');

  partialRE = /{{>\s*([\w-]+)\s*}}/g;

  Mustache = (function() {
    class Mustache {
      constructor(options = {}) {
        var ref, ref1;
        this.extension = (ref = options.extension) != null ? ref : 'mustache';
        this.path = (ref1 = options.path) != null ? ref1 : '.';
        this.pretty = options.pretty;
      }

      readFile(filename, callback) {
        var findFirst, fullPath, paths, regex;
        regex = new RegExp(`\.${this.extension}$`);
        filename = filename.replace(regex, '');
        paths = Array.isArray(this.path) ? this.path.slice(0) : [this.path];
        fullPath = void 0;
        findFirst = (callback) => {
          var file, path;
          path = paths.shift();
          if (path == null) {
            // Have we run out of paths?
            return callback(new Error(`File not found: ${filename}`));
          }
          file = this.extension != null ? Path.join(path, `${filename}.${this.extension}`) : Path.join(path, filename);
          return fs.access(file, fs.R_OK, function(err) {
            if (!err) {
              fullPath = file;
            }
            return callback(void 0); // Success
          });
        };
        // Try to find the file, one path at a time, in order
        return Async.doUntil(findFirst, function() {
          // Keep going until fullPath is set then stop, guaranteeing the 1st match
          return fullPath != null;
        }, (err) => {
          if (err) {
            return callback(err);
          }
          // Read the file
          return fs.readFile(fullPath, {
            encoding: 'utf-8'
          }, (err, data) => {
            var partials;
            if (err) {
              return callback(err);
            }
            // Find any partials
            partials = data.match(partialRE);
            // or pass an empty array
            if (partials == null) {
              partials = [];
            }
            // Deal with all the partials in parallel
            return Async.each(partials, (partial, cb) => {
              // and strip out the filename
              partial = partial.replace(partialRE, '$1');
              // Call readFile recursively to find partials within partials
              return this.readFile(partial, (err, part) => {
                if (err) {
                  return cb(err);
                }
                // Save partials off in the instance
                this.parts[partial] = part;
                return cb(void 0);
              });
            }, function(err) {
              // All partials done, pass back the template
              return callback(err, data);
            });
          });
        });
      }

      _render(file, context, callback) {
        this.parts = {};
        return this.readFile(file, (err, template) => {
          var result;
          if (err) {
            return callback(err);
          }
          try {
            result = mustache.render(template, context, this.parts);
          } catch (error) {
            err = error;
            return callback(err);
          }
          if (this.pretty) {
            result = Pretty(result, {
              ocd: true
            });
          }
          return callback(void 0, result);
        });
      }

      render(file, context, callback) {
        if (callback) {
          return this._render(file, context, callback);
        }
        return new Promise((resolve, reject) => {
          return this._render(file, context, function(err, result) {
            if (err) {
              return reject(err);
            }
            return resolve(result);
          });
        });
      }

    };

    Mustache.prototype.parts = {};

    return Mustache;

  }).call(this);

  module.exports = Mustache;

}).call(this);
